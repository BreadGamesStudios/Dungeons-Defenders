 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/index.html b/index.html
index 76de9e173e298e1875d31afa2811829a2e75f450..0b97ecc281ae8c6e045f60c4cc0414594cdd85e0 100644
--- a/index.html
+++ b/index.html
@@ -740,50 +740,54 @@
 
         .category-count {
             background: rgba(255,255,255,0.2);
             padding: 2px 8px;
             border-radius: 10px;
             font-size: 11px;
             margin-left: 8px;
         }
     </style>
 </head>
 <body>
     <div id="ui-panel">
         <div class="stats">
             <div class="stat">
                 <span class="stat-icon">â¤ï¸</span>
                 <span><span data-i18n="health">Vida</span>: <span id="health">100</span></span>
             </div>
             <div class="stat">
                 <span class="stat-icon">ğŸ’°</span>
                 <span><span data-i18n="gold">Ouro</span>: <span id="gold">1000</span></span>
             </div>
             <div class="stat kills">
                 <span class="stat-icon">ğŸ’€</span>
                 <span><span data-i18n="kills">Mortes</span>: <span id="kills">0</span></span>
             </div>
+            <div class="stat combo">
+                <span class="stat-icon">ğŸ”¥</span>
+                <span><span data-i18n="combo">Combo</span>: <span id="combo">x1</span></span>
+            </div>
             <div class="stage-info">
                 ğŸ° <span data-i18n="stage">Fase</span>: <span id="stage">1</span>
             </div>
             <div class="wave-info">
                 âš”ï¸ <span data-i18n="wave">Onda</span>: <span id="wave">0</span> / 25
             </div>
             <div class="language-selector">
                 <button class="lang-btn active" data-lang="pt" title="PortuguÃªs">ğŸ‡§ğŸ‡·</button>
                 <button class="lang-btn" data-lang="es" title="EspaÃ±ol">ğŸ‡ªğŸ‡¸</button>
                 <button class="lang-btn" data-lang="en" title="English">ğŸ‡ºğŸ‡¸</button>
             </div>
         </div>
         <div class="wave-controls">
             <button id="ability-btn" title="Habilidade Especial">âš¡ <span data-i18n="power">PODER</span></button>
             <button id="speed-btn">âš¡ 1x</button>
             <button id="auto-wave-btn">ğŸ”„ Auto: OFF</button>
             <button id="start-wave-btn">â–¶ï¸ <span data-i18n="startWave">Iniciar Onda</span></button>
         </div>
     </div>
     
     <div id="game-area">
         <canvas id="game-canvas"></canvas>
         <div id="shop-panel">
             <h2 class="shop-title">âš”ï¸ <span data-i18n="heroes">HERÃ“IS</span> âš”ï¸</h2>
             <div id="hero-shop"></div>
@@ -791,50 +795,51 @@
         </div>
     </div>
 
     <div id="upgrade-menu">
         <h3 id="menu-hero-name">ğŸ—¡ï¸ Guerreiro</h3>
         <div class="stats-info" id="menu-stats"></div>
         <div class="menu-buttons">
             <button id="upgrade-btn">â¬†ï¸ UPGRADE (ğŸ’°<span id="upgrade-cost">50</span>)</button>
             <button id="sell-btn">ğŸ’¸ <span data-i18n="sell">VENDER</span> (+<span id="sell-price">50</span>ğŸ’°)</button>
             <button id="close-menu-btn">âœ–ï¸ <span data-i18n="close">Fechar</span></button>
         </div>
     </div>
 
     <script>
         const canvas = document.getElementById('game-canvas');
         const ctx = canvas.getContext('2d');
         const upgradeMenu = document.getElementById('upgrade-menu');
 
         // Sistema de TraduÃ§Ã£o
         const translations = {
             pt: {
                 // UI
                 health: "Vida",
                 gold: "Ouro",
                 kills: "Mortes",
+                combo: "Combo",
                 stage: "Fase",
                 wave: "Onda",
                 power: "PODER",
                 startWave: "Iniciar Onda",
                 heroes: "HERÃ“IS",
                 sell: "VENDER",
                 close: "Fechar",
                 autoOn: "Auto: ON",
                 autoOff: "Auto: OFF",
                 
                 // Categorias
                 shooters: "Atiradores",
                 magic: "Magia",
                 legendary: "LendÃ¡rios",
                 support: "Suporte",
                 
                 // HerÃ³is
                 warrior: "Guerreiro",
                 archer: "Arqueiro",
                 assassin: "Assassino",
                 sniper: "Atirador",
                 cannon: "CanhÃ£o",
                 bomber: "Bombardeiro",
                 paladin: "Paladino",
                 mage: "Mago",
@@ -865,50 +870,57 @@
                 lightningDesc: "Atinge mÃºltiplos inimigos",
                 farmDesc: "Gera 10ğŸ’° a cada 12s",
                 
                 // Stats
                 damage: "Dano",
                 range: "Alcance",
                 speed: "Vel",
                 income: "Renda",
                 interval: "Intervalo",
                 level: "NÃ­vel",
                 invested: "Investido",
                 next: "PrÃ³ximo",
                 
                 // Mensagens
                 waveComplete: "ONDA {0} COMPLETA!",
                 bonus: "BÃ”NUS!",
                 nextWaveIn: "PrÃ³xima onda em 2s...",
                 infiniteMode: "MODO INFINITO!",
                 cannotPlace: "NÃ£o pode!",
                 tooClose: "Muito perto!",
                 meteor: "METEORO!",
                 hit: "ATINGIDOS!",
                 bossWarning: "âš ï¸ CHEFÃƒO APARECENDO! âš ï¸",
                 paused: "PAUSADA",
                 crit: "CRIT!",
+                comboBonus: "BÃ”NUS DE COMBO",
+                mutator: "Mutador",
+                mutatorNone: "PadrÃ£o",
+                mutatorFrenzy: "Frenesi",
+                mutatorTank: "Fortificados",
+                mutatorRegen: "RegeneraÃ§Ã£o",
+                mutatorGolden: "Tesouro",
                 
                 // Game Over
                 gameOver: "ğŸ’€ GAME OVER ğŸ’€",
                 victory: "ğŸ† VITÃ“RIA! ğŸ†",
                 totalWaves: "Total de Ondas",
                 heroesCount: "HerÃ³is",
                 farmsCount: "Fazendas",
                 tryAgain: "Tentar Fase {0} Novamente",
                 initialGold: "Ouro inicial",
                 goldMultiplier: "Multiplicador de ouro",
                 noHeroes: "Sem herÃ³is",
                 retryStage: "ğŸ”„ Tentar Fase {0} Novamente",
                 backToStage1: "ğŸ  Voltar para Fase 1",
                 playAgain: "ğŸ”„ Jogar Novamente",
                 
                 // Stage Complete
                 stageComplete: "ğŸ† FASE {0} COMPLETA! ğŸ†",
                 difficulty: "Dificuldade",
                 stageBonus: "BÃ´nus de Fase",
                 totalGold: "Ouro Total",
                 totalKills: "Total de Mortes",
                 currentGold: "Ouro atual",
                 nextStage: "PrÃ³xima fase",
                 nextStageInfo: "ğŸ“ FASE {0}",
                 enemiesStronger: "Inimigos +{0}% mais fortes",
@@ -928,50 +940,51 @@
                 impossible: "ImpossÃ­vel",
                 
                 // InstruÃ§Ãµes
                 instructions: `<strong>ğŸ“– COMO JOGAR:</strong><br>
                     1ï¸âƒ£ Clique na categoria<br>
                     2ï¸âƒ£ Passe o mouse para ver stats<br>
                     3ï¸âƒ£ Clique no herÃ³i â†’ posicione<br>
                     4ï¸âƒ£ Clique no colocado = menu<br><br>
                     <strong style="color:#e74c3c;">âš¡ PODER: Dano em Ã¡rea (30s)</strong>`,
                 
                 // Estruturas
                 evilLair: "â˜ ï¸ COVIL SOMBRIO",
                 cursedMountain: "ğŸ’€ MONTANHA MALDITA",
                 infernoPortal: "ğŸ”¥ PORTAL INFERNAL",
                 yourCastle: "ğŸ›¡ï¸ SEU CASTELO",
                 
                 // Achievements
                 kills100: "ğŸ’€ 100 MORTES!",
                 kills500: "âš”ï¸ 500 MORTES!"
             },
             es: {
                 // UI
                 health: "Vida",
                 gold: "Oro",
                 kills: "Muertes",
+                combo: "Combo",
                 stage: "Etapa",
                 wave: "Oleada",
                 power: "PODER",
                 startWave: "Iniciar Oleada",
                 heroes: "HÃ‰ROES",
                 sell: "VENDER",
                 close: "Cerrar",
                 autoOn: "Auto: ON",
                 autoOff: "Auto: OFF",
                 
                 // Categorias
                 shooters: "Tiradores",
                 magic: "Magia",
                 legendary: "Legendarios",
                 support: "Soporte",
                 
                 // HerÃ³is
                 warrior: "Guerrero",
                 archer: "Arquero",
                 assassin: "Asesino",
                 sniper: "Francotirador",
                 cannon: "CaÃ±Ã³n",
                 bomber: "Bombardero",
                 paladin: "PaladÃ­n",
                 mage: "Mago",
@@ -1002,50 +1015,57 @@
                 lightningDesc: "Alcanza mÃºltiples enemigos",
                 farmDesc: "Genera 10ğŸ’° cada 12s",
                 
                 // Stats
                 damage: "DaÃ±o",
                 range: "Alcance",
                 speed: "Vel",
                 income: "Ingreso",
                 interval: "Intervalo",
                 level: "Nivel",
                 invested: "Invertido",
                 next: "Siguiente",
                 
                 // Mensagens
                 waveComplete: "Â¡OLEADA {0} COMPLETADA!",
                 bonus: "Â¡BONUS!",
                 nextWaveIn: "PrÃ³xima oleada en 2s...",
                 infiniteMode: "Â¡MODO INFINITO!",
                 cannotPlace: "Â¡No puedes!",
                 tooClose: "Â¡Muy cerca!",
                 meteor: "Â¡METEORO!",
                 hit: "Â¡ALCANZADOS!",
                 bossWarning: "âš ï¸ Â¡JEFE APARECIENDO! âš ï¸",
                 paused: "PAUSADA",
                 crit: "Â¡CRIT!",
+                comboBonus: "BONO DE COMBO",
+                mutator: "Mutador",
+                mutatorNone: "EstÃ¡ndar",
+                mutatorFrenzy: "FrenesÃ­",
+                mutatorTank: "Fortificados",
+                mutatorRegen: "RegeneraciÃ³n",
+                mutatorGolden: "Tesoro",
                 
                 // Game Over
                 gameOver: "ğŸ’€ FIN DEL JUEGO ğŸ’€",
                 victory: "ğŸ† Â¡VICTORIA! ğŸ†",
                 totalWaves: "Total de Oleadas",
                 heroesCount: "HÃ©roes",
                 farmsCount: "Granjas",
                 tryAgain: "Intentar Etapa {0} Nuevamente",
                 initialGold: "Oro inicial",
                 goldMultiplier: "Multiplicador de oro",
                 noHeroes: "Sin hÃ©roes",
                 retryStage: "ğŸ”„ Intentar Etapa {0} Nuevamente",
                 backToStage1: "ğŸ  Volver a Etapa 1",
                 playAgain: "ğŸ”„ Jugar Nuevamente",
                 
                 // Stage Complete
                 stageComplete: "ğŸ† Â¡ETAPA {0} COMPLETADA! ğŸ†",
                 difficulty: "Dificultad",
                 stageBonus: "Bonus de Etapa",
                 totalGold: "Oro Total",
                 totalKills: "Total de Muertes",
                 currentGold: "Oro actual",
                 nextStage: "PrÃ³xima etapa",
                 nextStageInfo: "ğŸ“ ETAPA {0}",
                 enemiesStronger: "Enemigos +{0}% mÃ¡s fuertes",
@@ -1065,50 +1085,51 @@
                 impossible: "Imposible",
                 
                 // InstruÃ§Ãµes
                 instructions: `<strong>ğŸ“– CÃ“MO JUGAR:</strong><br>
                     1ï¸âƒ£ Haz clic en la categorÃ­a<br>
                     2ï¸âƒ£ Pasa el mouse para ver stats<br>
                     3ï¸âƒ£ Clic en hÃ©roe â†’ posiciona<br>
                     4ï¸âƒ£ Clic en colocado = menÃº<br><br>
                     <strong style="color:#e74c3c;">âš¡ PODER: DaÃ±o en Ã¡rea (30s)</strong>`,
                 
                 // Estruturas
                 evilLair: "â˜ ï¸ GUARIDA MALVADA",
                 cursedMountain: "ğŸ’€ MONTAÃ‘A MALDITA",
                 infernoPortal: "ğŸ”¥ PORTAL INFERNAL",
                 yourCastle: "ğŸ›¡ï¸ TU CASTILLO",
                 
                 // Achievements
                 kills100: "ğŸ’€ Â¡100 MUERTES!",
                 kills500: "âš”ï¸ Â¡500 MUERTES!"
             },
             en: {
                 // UI
                 health: "Health",
                 gold: "Gold",
                 kills: "Kills",
+                combo: "Combo",
                 stage: "Stage",
                 wave: "Wave",
                 power: "POWER",
                 startWave: "Start Wave",
                 heroes: "HEROES",
                 sell: "SELL",
                 close: "Close",
                 autoOn: "Auto: ON",
                 autoOff: "Auto: OFF",
                 
                 // Categorias
                 shooters: "Shooters",
                 magic: "Magic",
                 legendary: "Legendary",
                 support: "Support",
                 
                 // HerÃ³is
                 warrior: "Warrior",
                 archer: "Archer",
                 assassin: "Assassin",
                 sniper: "Sniper",
                 cannon: "Cannon",
                 bomber: "Bomber",
                 paladin: "Paladin",
                 mage: "Mage",
@@ -1139,50 +1160,57 @@
                 lightningDesc: "Hits multiple enemies",
                 farmDesc: "Generates 10ğŸ’° every 12s",
                 
                 // Stats
                 damage: "Damage",
                 range: "Range",
                 speed: "Speed",
                 income: "Income",
                 interval: "Interval",
                 level: "Level",
                 invested: "Invested",
                 next: "Next",
                 
                 // Mensagens
                 waveComplete: "WAVE {0} COMPLETE!",
                 bonus: "BONUS!",
                 nextWaveIn: "Next wave in 2s...",
                 infiniteMode: "INFINITE MODE!",
                 cannotPlace: "Can't place!",
                 tooClose: "Too close!",
                 meteor: "METEOR!",
                 hit: "HIT!",
                 bossWarning: "âš ï¸ BOSS INCOMING! âš ï¸",
                 paused: "PAUSED",
                 crit: "CRIT!",
+                comboBonus: "COMBO BONUS",
+                mutator: "Mutator",
+                mutatorNone: "Standard",
+                mutatorFrenzy: "Frenzy",
+                mutatorTank: "Fortified",
+                mutatorRegen: "Regeneration",
+                mutatorGolden: "Treasure",
                 
                 // Game Over
                 gameOver: "ğŸ’€ GAME OVER ğŸ’€",
                 victory: "ğŸ† VICTORY! ğŸ†",
                 totalWaves: "Total Waves",
                 heroesCount: "Heroes",
                 farmsCount: "Farms",
                 tryAgain: "Try Stage {0} Again",
                 initialGold: "Initial gold",
                 goldMultiplier: "Gold multiplier",
                 noHeroes: "No heroes",
                 retryStage: "ğŸ”„ Try Stage {0} Again",
                 backToStage1: "ğŸ  Back to Stage 1",
                 playAgain: "ğŸ”„ Play Again",
                 
                 // Stage Complete
                 stageComplete: "ğŸ† STAGE {0} COMPLETE! ğŸ†",
                 difficulty: "Difficulty",
                 stageBonus: "Stage Bonus",
                 totalGold: "Total Gold",
                 totalKills: "Total Kills",
                 currentGold: "Current gold",
                 nextStage: "Next stage",
                 nextStageInfo: "ğŸ“ STAGE {0}",
                 enemiesStronger: "Enemies +{0}% stronger",
@@ -1286,51 +1314,63 @@
             gold: 1000,
             wave: 0,
             maxWaves: 25,
             stage: 1,
             gameSpeed: 1,
             enemies: [],
             heroes: [],
             projectiles: [],
             effects: [],
             selectedHeroType: null,
             selectedHeroForUpgrade: null,
             waveActive: false,
             autoWave: false,
             gameOver: false,
             stagePaused: false,
             path: [],
             enemiesSpawned: 0,
             totalEnemiesToSpawn: 0,
             menuPosition: { x: 0, y: 0 },
             kills: 0,
             abilityCooldown: 0,
             abilityReady: true,
             lastAbilityUse: 0,
             criticalChance: 0.10,
             bossWarningActive: false,
-            achievements: []
+            achievements: [],
+            combo: 1,
+            maxCombo: 1,
+            comboTimeout: 0,
+            waveMutator: null
+        };
+
+        const waveMutators = {
+            none: { key: "mutatorNone", healthMult: 1, speedMult: 1, goldMult: 1, armorBonus: 0, regenRate: 0, aura: null },
+            frenzy: { key: "mutatorFrenzy", healthMult: 0.9, speedMult: 1.35, goldMult: 1.2, armorBonus: 0, regenRate: 0, aura: "#e74c3c" },
+            tank: { key: "mutatorTank", healthMult: 1.45, speedMult: 0.82, goldMult: 1.3, armorBonus: 0.08, regenRate: 0, aura: "#95a5a6" },
+            regen: { key: "mutatorRegen", healthMult: 1.2, speedMult: 1, goldMult: 1.25, armorBonus: 0, regenRate: 0.004, aura: "#2ecc71" },
+            golden: { key: "mutatorGolden", healthMult: 1.1, speedMult: 1.1, goldMult: 1.65, armorBonus: 0, regenRate: 0, aura: "#f1c40f" }
         };
 
         const heroCategories = {
             shooters: {
                 icon: 'ğŸ¹',
                 heroes: ['warrior', 'archer', 'assassin', 'sniper', 'cannon', 'bomber', 'paladin']
             },
             magic: {
                 icon: 'ğŸ”®',
                 heroes: ['mage', 'cleric', 'frost', 'necro']
             },
             legendary: {
                 icon: 'â­',
                 heroes: ['templar', 'ninja', 'druid', 'lightning']
             },
             support: {
                 icon: 'ğŸŒ¾',
                 heroes: ['farm']
             }
         };
 
         const heroTypes = {
             warrior: { image: 'ğŸ—¡ï¸', cost: 100, damage: 55, range: 100, attackSpeed: 500, color: '#e74c3c', type: 'combat', category: 'shooters' },
             archer: { image: 'ğŸ¹', cost: 150, damage: 25, range: 200, attackSpeed: 800, color: '#27ae60', type: 'combat', category: 'shooters' },
             assassin: { image: 'ğŸ—¡ï¸', cost: 180, damage: 80, range: 80, attackSpeed: 350, color: '#8e44ad', type: 'combat', category: 'shooters' },
@@ -1352,50 +1392,98 @@
         const enemyTypes = {
             goblin: { name: 'Goblin', emoji: 'ğŸ‘º', health: 50, speed: 1.8, damage: 5, gold: 3 },
             orc: { name: 'Orc', emoji: 'ğŸ‘¹', health: 100, speed: 1.4, damage: 10, gold: 5 },
             troll: { name: 'Troll', emoji: 'ğŸ§Ÿ', health: 200, speed: 1.0, damage: 15, gold: 7 },
             ogre: { name: 'Ogre', emoji: 'ğŸ‘¾', health: 350, speed: 0.8, damage: 25, gold: 10 },
             dragon: { name: 'DragÃ£o', emoji: 'ğŸ‰', health: 500, speed: 1.2, damage: 40, gold: 25 },
             demon: { name: 'DemÃ´nio', emoji: 'ğŸ‘¿', health: 800, speed: 1.5, damage: 50, gold: 40 },
             boss: { name: 'ChefÃ£o', emoji: 'ğŸ’€', health: 2000, speed: 0.6, damage: 100, gold: 100 }
         };
 
         const stageDifficulty = {
             1: { key: 'normal', class: 'diff-normal' },
             2: { key: 'hard', class: 'diff-hard' },
             3: { key: 'nightmare', class: 'diff-nightmare' },
             4: { key: 'hell', class: 'diff-hell' },
             5: { key: 'impossible', class: 'diff-inferno' }
         };
 
         function calculateDamage(baseDamage) {
             if (Math.random() < game.criticalChance) {
                 return { damage: baseDamage * 1.25, isCritical: true };
             }
             return { damage: baseDamage, isCritical: false };
         }
 
+        function resetCombo() {
+            game.combo = 1;
+            game.maxCombo = 1;
+            game.comboTimeout = 0;
+        }
+
+        function registerKill() {
+            const now = Date.now();
+            if (now < game.comboTimeout) game.combo = Math.min(20, game.combo + 1);
+            else game.combo = 1;
+            game.comboTimeout = now + 3000;
+            game.maxCombo = Math.max(game.maxCombo, game.combo);
+        }
+
+        function getComboDamageMultiplier() {
+            return 1 + Math.min(0.4, (game.combo - 1) * 0.02);
+        }
+
+        function handleEnemyDefeat(enemy) {
+            enemy.dead = true;
+            registerKill();
+            game.gold += enemy.gold;
+            game.kills++;
+
+            if (game.kills === 100 && !game.achievements.includes('kills100')) {
+                showAchievement('kills100', '+200 ' + t('gold'));
+                game.gold += 200;
+                game.achievements.push('kills100');
+            }
+            if (game.kills === 500 && !game.achievements.includes('kills500')) {
+                showAchievement('kills500', '+1000 ' + t('gold'));
+                game.gold += 1000;
+                game.achievements.push('kills500');
+            }
+
+            const comboText = game.combo > 1 ? ` x${game.combo}` : '';
+            game.effects.push({ x: enemy.x, y: enemy.y, text: `+${enemy.gold}ğŸ’°${comboText}`, color: '#f1c40f', life: 35 });
+            updateUI();
+        }
+
+        function chooseWaveMutator() {
+            const mutatorPool = ['none', 'frenzy', 'tank', 'regen', 'golden'];
+            const waveScale = Math.min(0.85, game.wave / 35);
+            const guaranteed = game.wave > 4 && Math.random() < waveScale;
+            const pick = guaranteed ? mutatorPool[1 + Math.floor(Math.random() * (mutatorPool.length - 1))] : 'none';
+            game.waveMutator = waveMutators[pick];
+        }
+
         function useAbility() {
             if (!game.abilityReady || game.abilityCooldown > 0) return;
             
             game.abilityReady = false;
             game.lastAbilityUse = Date.now();
             game.abilityCooldown = 30;
             
             const meteorX = canvas.width / 2;
             const meteorY = canvas.height / 2;
             
             let hitCount = 0;
             for (const enemy of game.enemies) {
                 if (enemy.dead) continue;
                 const dist = Math.sqrt((enemy.x - meteorX) ** 2 + (enemy.y - meteorY) ** 2);
                 if (dist < 200) {
                     const damage = 200 * (1 - dist / 200);
                     enemy.takeDamage(damage);
                     hitCount++;
                 }
             }
             
             game.effects.push({ x: meteorX, y: meteorY, text: 'â˜„ï¸ ' + t('meteor'), color: '#e74c3c', life: 60 });
             
             if (hitCount > 0) {
                 game.effects.push({ x: meteorX, y: meteorY + 30, text: `ğŸ’¥ ${hitCount} ${t('hit')}`, color: '#f39c12', life: 50 });
@@ -1487,203 +1575,204 @@
                 for (let i = 1; i < segments; i++) {
                     const progress = i / segments;
                     const x = startX + (endX - startX) * progress;
                     const yOffset = (i % 2 === 0 ? 1 : -1) * amplitude * (0.7 + Math.random() * 0.3);
                     path.push({ x, y: centerY + yOffset });
                 }
                 path.push({ x: endX, y: centerY });
             }
             
             game.path = path;
         }
 
         function getDifficultyMultiplier() { return 1 + (game.stage - 1) * 0.4; }
         function getSpeedMultiplier() { return 1 + (game.stage - 1) * 0.15; }
 
         class Enemy {
             constructor(type) {
                 const config = enemyTypes[type];
                 const diffMult = getDifficultyMultiplier();
                 const speedMult = getSpeedMultiplier();
                 const goldMult = getGoldMultiplier(game.stage);
                 
                 this.type = type;
                 this.emoji = config.emoji;
                 this.maxHealth = Math.floor(config.health * (1 + game.wave * 0.15) * diffMult);
+                if (game.waveMutator) this.maxHealth = Math.floor(this.maxHealth * game.waveMutator.healthMult);
                 this.health = this.maxHealth;
                 this.baseSpeed = config.speed * speedMult;
+                if (game.waveMutator) this.baseSpeed *= game.waveMutator.speedMult;
                 this.speed = this.baseSpeed;
                 this.damage = Math.floor(config.damage * diffMult);
                 this.gold = Math.floor(config.gold * goldMult);
+                if (game.waveMutator) this.gold = Math.floor(this.gold * game.waveMutator.goldMult);
                 this.pathIndex = 0;
                 this.x = game.path[0].x;
                 this.y = game.path[0].y;
                 this.size = type === 'boss' ? 50 : 38;
                 this.dead = false;
                 this.armor = type === 'boss' ? 0.3 : (type === 'demon' ? 0.2 : 0);
+                if (game.waveMutator) this.armor += game.waveMutator.armorBonus;
                 this.slowed = false;
                 this.slowTimer = 0;
                 this.poisoned = false;
                 this.poisonDamage = 0;
                 this.poisonTimer = 0;
+                this.regenRate = game.waveMutator ? game.waveMutator.regenRate : 0;
             }
 
             update() {
                 if (this.dead) return;
 
                 if (this.poisoned && this.poisonTimer > 0) {
                     this.poisonTimer -= game.gameSpeed;
                     if (Math.random() < 0.05 * game.gameSpeed) {
                         this.health -= this.poisonDamage;
                         game.effects.push({ x: this.x + (Math.random() - 0.5) * 15, y: this.y - 15, text: `â˜ ï¸${Math.floor(this.poisonDamage)}`, color: '#6c3483', life: 20 });
-                        if (this.health <= 0) { this.dead = true; game.gold += this.gold; game.kills++; updateUI(); return; }
+                        if (this.health <= 0) { handleEnemyDefeat(this); return; }
                     }
                 } else { this.poisoned = false; }
 
+                if (this.regenRate > 0 && this.health > 0 && this.health < this.maxHealth) {
+                    this.health = Math.min(this.maxHealth, this.health + this.maxHealth * this.regenRate * game.gameSpeed);
+                }
+
                 if (this.slowed && this.slowTimer > 0) { this.slowTimer -= game.gameSpeed; this.speed = this.baseSpeed * 0.5; }
                 else { this.slowed = false; this.speed = this.baseSpeed; }
 
                 const target = game.path[this.pathIndex + 1];
                 if (!target) { this.reachCastle(); return; }
 
                 const dx = target.x - this.x;
                 const dy = target.y - this.y;
                 const dist = Math.sqrt(dx * dx + dy * dy);
 
                 if (dist < 10) {
                     this.pathIndex++;
                     if (this.pathIndex >= game.path.length - 1) this.reachCastle();
                 } else {
                     const currentSpeed = this.speed * game.gameSpeed;
                     this.x += (dx / dist) * currentSpeed;
                     this.y += (dy / dist) * currentSpeed;
                 }
             }
 
             reachCastle() {
                 if (this.dead) return;
                 this.dead = true;
                 game.health -= this.damage;
                 updateUI();
                 if (game.health <= 0) { game.health = 0; endGame(false); }
             }
 
             draw() {
                 if (this.dead) return;
 
                 ctx.fillStyle = 'rgba(0,0,0,0.4)';
                 ctx.beginPath();
                 ctx.ellipse(this.x, this.y + 22, 18, 10, 0, 0, Math.PI * 2);
                 ctx.fill();
 
                 ctx.font = `${this.size}px Arial`;
                 ctx.textAlign = 'center';
                 ctx.textBaseline = 'middle';
                 ctx.fillText(this.emoji, this.x, this.y);
 
                 if (this.slowed) { ctx.fillStyle = 'rgba(116, 185, 255, 0.4)'; ctx.beginPath(); ctx.arc(this.x, this.y, 25, 0, Math.PI * 2); ctx.fill(); }
                 if (this.poisoned) { ctx.fillStyle = 'rgba(108, 52, 131, 0.4)'; ctx.beginPath(); ctx.arc(this.x, this.y, 22, 0, Math.PI * 2); ctx.fill(); }
+                if (game.waveMutator && game.waveMutator.aura) {
+                    ctx.strokeStyle = game.waveMutator.aura;
+                    ctx.lineWidth = 2;
+                    ctx.beginPath();
+                    ctx.arc(this.x, this.y, 27, 0, Math.PI * 2);
+                    ctx.stroke();
+                }
 
                 const barWidth = 46, barHeight = 8;
                 const healthPct = this.health / this.maxHealth;
                 ctx.fillStyle = '#000';
                 ctx.fillRect(this.x - barWidth/2 - 2, this.y - 30, barWidth + 4, barHeight + 4);
                 ctx.fillStyle = healthPct > 0.6 ? '#2ecc71' : healthPct > 0.3 ? '#f39c12' : '#e74c3c';
                 ctx.fillRect(this.x - barWidth/2, this.y - 28, barWidth * healthPct, barHeight);
                 
                 if (this.armor > 0) { ctx.fillStyle = '#ecf0f1'; ctx.font = 'bold 10px Arial'; ctx.fillText('ğŸ›¡ï¸', this.x + 20, this.y - 25); }
             }
 
             takeDamage(dmg, heroType = null) {
                 if (this.dead) return;
                 
                 const finalDamage = dmg * (1 - this.armor);
                 this.health -= finalDamage;
                 
                 if (heroType === 'frost') { this.slowed = true; this.slowTimer = 120; }
                 if (heroType === 'necro') { this.poisoned = true; this.poisonDamage = dmg * 0.3; this.poisonTimer = 180; }
                 
                 game.effects.push({ x: this.x + (Math.random() - 0.5) * 20, y: this.y - 20, text: `-${Math.floor(finalDamage)}`, color: '#ff6b6b', life: 25 });
                 
                 if (this.health <= 0) {
-                    this.dead = true;
-                    game.gold += this.gold;
-                    game.kills++;
-                    
-                    if (game.kills === 100 && !game.achievements.includes('kills100')) {
-                        showAchievement('kills100', '+200 ' + t('gold'));
-                        game.gold += 200;
-                        game.achievements.push('kills100');
-                    }
-                    if (game.kills === 500 && !game.achievements.includes('kills500')) {
-                        showAchievement('kills500', '+1000 ' + t('gold'));
-                        game.gold += 1000;
-                        game.achievements.push('kills500');
-                    }
-                    
-                    game.effects.push({ x: this.x, y: this.y, text: `+${this.gold}ğŸ’°`, color: '#f1c40f', life: 35 });
-                    updateUI();
+                    handleEnemyDefeat(this);
                 }
             }
         }
 
         class Hero {
             constructor(type, x, y) {
                 const config = heroTypes[type];
                 this.type = type;
                 this.heroType = config.type;
                 this.image = config.image;
                 this.x = x;
                 this.y = y;
                 this.baseCost = config.cost;
                 this.baseDamage = config.damage;
                 this.damage = config.damage;
                 this.baseRange = config.range;
                 this.range = config.range;
                 this.baseAttackSpeed = config.attackSpeed;
                 this.attackSpeed = config.attackSpeed;
                 this.color = config.color;
                 this.lastAttack = 0;
                 this.lastGoldTick = 0;
                 this.level = 1;
                 this.upgradeCost = Math.floor(config.cost * 0.5);
                 this.target = null;
                 this.totalInvested = config.cost;
                 
                 if (type === 'farm') { this.goldPerTick = config.goldPerTick; this.tickInterval = config.attackSpeed; }
             }
 
             getSellPrice() { return Math.floor(this.totalInvested * 0.5); }
 
             getDamageWithBuffs() {
                 let damage = this.damage;
                 for (const hero of game.heroes) {
                     if (hero.type === 'paladin' && hero !== this) {
                         const dist = Math.sqrt((this.x - hero.x) ** 2 + (this.y - hero.y) ** 2);
                         if (dist < 150) { damage *= 1.2; break; }
                     }
                 }
+                damage *= getComboDamageMultiplier();
                 return damage;
             }
 
             update() {
                 const now = Date.now();
                 
                 if (this.type === 'farm') {
                     if (!game.waveActive) { this.lastGoldTick = now; return; }
                     if (this.lastGoldTick === 0) this.lastGoldTick = now;
                     const adjustedInterval = this.tickInterval / game.gameSpeed;
                     if (now - this.lastGoldTick >= adjustedInterval) {
                         game.gold += this.goldPerTick;
                         game.effects.push({ x: this.x, y: this.y - 30, text: `+${this.goldPerTick}ğŸ’°`, color: '#f39c12', life: 30 });
                         this.lastGoldTick = now;
                         updateUI();
                     }
                     return;
                 }
                 
                 if (this.type === 'cleric' && game.health < 100 && game.health > 0) {
                     const adjustedSpeed = this.attackSpeed / game.gameSpeed;
                     if (now - this.lastAttack > adjustedSpeed) { game.health = Math.min(100, game.health + 1 + this.level); updateUI(); }
                 }
 
                 if (this.type === 'druid') {
@@ -2165,110 +2254,126 @@
             const btn = document.getElementById('speed-btn');
             if (game.gameSpeed === 1) { game.gameSpeed = 2; btn.textContent = 'âš¡ 2x'; btn.classList.add('active'); }
             else { game.gameSpeed = 1; btn.textContent = 'âš¡ 1x'; btn.classList.remove('active'); }
         }
 
         document.getElementById('auto-wave-btn').addEventListener('click', toggleAutoWave);
 
         function toggleAutoWave() {
             game.autoWave = !game.autoWave;
             const btn = document.getElementById('auto-wave-btn');
             if (game.autoWave) {
                 btn.textContent = 'ğŸ”„ ' + t('autoOn');
                 btn.classList.add('active');
                 if (!game.waveActive && !game.gameOver && !game.stagePaused && game.wave < game.maxWaves) setTimeout(startWave, 500);
             } else {
                 btn.textContent = 'ğŸ”„ ' + t('autoOff');
                 btn.classList.remove('active');
             }
         }
 
         document.getElementById('start-wave-btn').addEventListener('click', startWave);
 
         function startWave() {
             if (game.waveActive || game.gameOver || game.stagePaused) return;
             game.wave++; game.waveActive = true; game.enemiesSpawned = 0;
+            resetCombo();
+            chooseWaveMutator();
             document.getElementById('start-wave-btn').disabled = true;
 
             const now = Date.now();
             for (const hero of game.heroes) { if (hero.type === 'farm') hero.lastGoldTick = now; }
 
             let enemyCount, types, speedMult;
             const stageBonus = game.stage - 1;
             
             if (game.wave === 25) showBossWarning();
             
             if (game.wave <= 3) { enemyCount = 5 + game.wave * 2 + stageBonus * 3; types = ['goblin']; if (game.stage >= 3) types.push('orc'); speedMult = 1; }
             else if (game.wave <= 6) { enemyCount = 8 + game.wave * 2 + stageBonus * 4; types = ['goblin', 'orc']; if (game.stage >= 2) types.push('troll'); speedMult = 1.1; }
             else if (game.wave <= 10) { enemyCount = 12 + game.wave * 2 + stageBonus * 5; types = ['goblin', 'orc', 'troll']; if (game.stage >= 3) types.push('ogre'); speedMult = 1.15; }
             else if (game.wave <= 15) { enemyCount = 18 + game.wave * 2 + stageBonus * 6; types = ['orc', 'troll', 'ogre']; if (game.stage >= 2) types.push('dragon'); if (game.stage >= 4) types.push('demon'); speedMult = 1.2; }
             else if (game.wave <= 20) { enemyCount = 25 + game.wave * 2 + stageBonus * 7; types = ['troll', 'ogre', 'dragon']; if (game.stage >= 3) types.push('demon'); speedMult = 1.25; }
             else if (game.wave <= 24) { enemyCount = 30 + game.wave * 2 + stageBonus * 8; types = ['ogre', 'dragon', 'demon']; speedMult = 1.3; }
             else { enemyCount = 15 + stageBonus * 5; types = ['dragon', 'demon', 'boss']; speedMult = 1.35; }
 
             game.totalEnemiesToSpawn = enemyCount;
+            if (game.waveMutator && game.waveMutator.key !== "mutatorNone") {
+                game.effects.push({
+                    x: canvas.width / 2,
+                    y: 110,
+                    text: `ğŸ§¬ ${t('mutator')}: ${t(game.waveMutator.key)}`,
+                    color: game.waveMutator.aura || "#9b59b6",
+                    life: 75
+                });
+            }
 
             const spawnInterval = setInterval(() => {
                 if (game.enemiesSpawned >= enemyCount || game.gameOver) { clearInterval(spawnInterval); return; }
                 const type = types[Math.floor(Math.random() * types.length)];
                 const enemy = new Enemy(type);
                 enemy.baseSpeed *= speedMult;
                 game.enemies.push(enemy);
                 game.enemiesSpawned++;
             }, 600 / game.gameSpeed);
 
             updateUI();
         }
 
         function updateUI() {
             document.getElementById('health').textContent = Math.max(0, Math.floor(game.health));
             document.getElementById('gold').textContent = game.gold;
             document.getElementById('wave').textContent = game.wave;
             document.getElementById('stage').textContent = game.stage;
             document.getElementById('kills').textContent = game.kills;
+            document.getElementById('combo').textContent = `x${game.combo}`;
 
             document.querySelectorAll('.hero-card').forEach(card => {
                 const type = card.dataset.type;
                 if (heroTypes[type]) card.classList.toggle('disabled', game.gold < heroTypes[type].cost);
             });
 
             if (game.selectedHeroForUpgrade) updateUpgradeMenuContent();
         }
 
         function checkWaveEnd() {
             if (!game.waveActive || game.gameOver) return;
             const aliveEnemies = game.enemies.filter(e => !e.dead);
             
             if (aliveEnemies.length === 0 && game.enemiesSpawned >= game.totalEnemiesToSpawn) {
                 game.waveActive = false; game.enemies = [];
                 document.getElementById('start-wave-btn').disabled = false;
 
                 const bonus = 30 + game.wave * 10 + game.stage * 20;
-                game.gold += bonus;
+                const comboBonus = Math.floor((game.maxCombo - 1) * 8);
+                game.gold += bonus + comboBonus;
                 
                 game.effects.push({ x: canvas.width / 2, y: canvas.height / 2 - 50, text: `ğŸ‰ ${t('waveComplete', game.wave)}`, color: '#f1c40f', life: 50 });
                 game.effects.push({ x: canvas.width / 2, y: canvas.height / 2, text: `+${bonus}ğŸ’° ${t('bonus')}`, color: '#2ecc71', life: 50 });
+                if (comboBonus > 0) {
+                    game.effects.push({ x: canvas.width / 2, y: canvas.height / 2 + 35, text: `ğŸ”¥ +${comboBonus}ğŸ’° ${t('comboBonus')}`, color: '#e67e22', life: 55 });
+                }
                 
                 updateUI();
 
                 if (game.wave >= game.maxWaves) setTimeout(() => showStageComplete(), 1500);
                 else if (game.autoWave) {
                     game.effects.push({ x: canvas.width / 2, y: canvas.height / 2 + 50, text: `ğŸ”„ ${t('nextWaveIn')}`, color: '#9b59b6', life: 60 });
                     setTimeout(() => { if (game.autoWave && !game.gameOver && !game.stagePaused) startWave(); }, 2000 / game.gameSpeed);
                 }
             }
         }
 
         function showStageComplete() {
             game.stagePaused = true; game.autoWave = false;
             document.getElementById('auto-wave-btn').textContent = 'ğŸ”„ ' + t('autoOff');
             document.getElementById('auto-wave-btn').classList.remove('active');
 
             const stageBonus = 500 * game.stage;
             game.gold += stageBonus;
             
             const nextStage = game.stage + 1;
             const nextDiff = stageDifficulty[Math.min(nextStage, 5)];
             const currentDiff = stageDifficulty[Math.min(game.stage, 5)];
             const currentGoldMult = getGoldMultiplier(game.stage);
             const nextGoldMult = getGoldMultiplier(nextStage);
 
@@ -2317,50 +2422,52 @@
                 generatePath(); updateUI();
             });
 
             document.getElementById('continue-endless-btn').addEventListener('click', () => {
                 game.wave = 0; game.maxWaves = 25; game.stagePaused = false;
                 document.getElementById('stage-complete-screen').remove();
                 updateUI();
                 game.effects.push({ x: canvas.width / 2, y: canvas.height / 2, text: `â™¾ï¸ ${t('infiniteMode')}`, color: '#3498db', life: 60 });
             });
 
             document.getElementById('restart-game-btn').addEventListener('click', () => location.reload());
             updateUI();
         }
 
         function getDifficultyMultiplierForStage(stage) { return 1 + (stage - 1) * 0.4; }
 
         function restartCurrentStage() {
             const currentStage = game.stage;
             game.health = 100; game.gold = getStartingGold(currentStage);
             game.wave = 0; game.maxWaves = 25; game.enemies = []; game.heroes = [];
             game.projectiles = []; game.effects = []; game.selectedHeroType = null;
             game.selectedHeroForUpgrade = null; game.waveActive = false; game.autoWave = false;
             game.gameOver = false; game.stagePaused = false; game.enemiesSpawned = 0;
             game.totalEnemiesToSpawn = 0; game.gameSpeed = 1; game.kills = 0;
             game.abilityCooldown = 0; game.abilityReady = true; game.lastAbilityUse = 0;
+            resetCombo();
+            game.waveMutator = null;
             
             document.getElementById('auto-wave-btn').textContent = 'ğŸ”„ ' + t('autoOff');
             document.getElementById('auto-wave-btn').classList.remove('active');
             document.getElementById('speed-btn').textContent = 'âš¡ 1x';
             document.getElementById('speed-btn').classList.remove('active');
             document.getElementById('start-wave-btn').disabled = false;
             
             const gameOverScreen = document.getElementById('game-over-screen');
             if (gameOverScreen) gameOverScreen.remove();
             
             closeUpgradeMenu(); generatePath(); updateUI(); gameLoop();
         }
 
         function endGame(victory) {
             game.gameOver = true; game.autoWave = false;
             document.getElementById('auto-wave-btn').textContent = 'ğŸ”„ ' + t('autoOff');
             document.getElementById('auto-wave-btn').classList.remove('active');
 
             const screen = document.createElement('div');
             screen.className = 'game-over-screen';
             screen.id = 'game-over-screen';
             
             const totalFarms = game.heroes.filter(h => h.type === 'farm').length;
             const totalWaves = (game.stage - 1) * 25 + game.wave;
             const currentDiff = stageDifficulty[Math.min(game.stage, 5)];
@@ -2400,50 +2507,54 @@
                     </div>
                 `;
                 document.body.appendChild(screen);
                 document.getElementById('retry-stage-btn').addEventListener('click', () => restartCurrentStage());
                 document.getElementById('restart-game-btn').addEventListener('click', () => location.reload());
             }
         }
 
         function gameLoop() {
             if (game.gameOver) return;
             drawBackground(); drawPath(); drawStructures();
             for (const hero of game.heroes) { hero.update(); hero.draw(); }
             for (const enemy of game.enemies) { if (!enemy.dead) { enemy.update(); enemy.draw(); } }
             game.projectiles = game.projectiles.filter(p => !p.dead);
             for (const projectile of game.projectiles) { projectile.update(); projectile.draw(); }
             drawEffects(); checkWaveEnd(); updateAbilityCooldown();
 
             const diff = stageDifficulty[Math.min(game.stage, 5)];
             const goldMult = getGoldMultiplier(game.stage);
             ctx.font = 'bold 14px Arial'; ctx.fillStyle = '#fff'; ctx.textAlign = 'left';
             ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
             const speedText = game.gameSpeed > 1 ? ` | âš¡${game.gameSpeed}x` : '';
             const stageText = `ğŸ° ${t('stage').toUpperCase()} ${game.stage} - ${t(diff.key)} | ğŸ’° ${goldMult}x ${t('gold').toLowerCase()}${speedText}`;
             ctx.strokeText(stageText, 15, 25);
             ctx.fillText(stageText, 15, 25);
+            const mutatorText = game.waveMutator ? `${t('mutator')}: ${t(game.waveMutator.key)}` : `${t('mutator')}: ${t('mutatorNone')}`;
+            ctx.font = "bold 13px Arial";
+            ctx.strokeText(`ğŸ”¥ Combo x${game.combo} | ğŸ§¬ ${mutatorText}`, 15, 44);
+            ctx.fillText(`ğŸ”¥ Combo x${game.combo} | ğŸ§¬ ${mutatorText}`, 15, 44);
 
             if (game.selectedHeroType && !game.stagePaused) {
                 ctx.font = 'bold 18px Arial'; ctx.fillStyle = '#fff';
                 ctx.strokeStyle = '#000'; ctx.lineWidth = 4; ctx.textAlign = 'center';
                 const config = heroTypes[game.selectedHeroType];
                 const text = `ğŸ¯ ${config.image} ${t(game.selectedHeroType)}`;
                 ctx.strokeText(text, canvas.width / 2, canvas.height - 25);
                 ctx.fillText(text, canvas.width / 2, canvas.height - 25);
             }
 
             requestAnimationFrame(gameLoop);
         }
 
         function init() {
             setupCanvas();
             createShop();
             document.getElementById('instructions').innerHTML = t('instructions');
             updateUI();
             gameLoop();
         }
 
         window.addEventListener('load', init);
         window.addEventListener('resize', () => setupCanvas());
     </script>
 </body>
 
EOF
)
